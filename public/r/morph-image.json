{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "morph-image",
  "type": "registry:component",
  "description": "A morph image component for shadcn/ui. Easily create a morph image with a thumbnail and a modal",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "registry/new-york/components/morph-image.tsx",
      "content": "\"use client\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport type React from \"react\";\n\nimport { AnimatePresence, motion, type Transition } from \"motion/react\";\n\nimport { useClickOutside } from \"@/registry/new-york/hooks/useClickOutside\";\nimport { useEventListener } from \"@/registry/new-york/hooks/useEventListener\";\nimport { cn } from \"@/shadcn/lib/utils\";\n\nconst transition: Transition = {\n    duration: 0.3,\n    ease: [0.4, 0, 0.2, 1],\n    type: \"spring\",\n    stiffness: 120,\n    damping: 15,\n};\n\nconst MorphImage: React.FC<\n    Omit<React.ComponentProps<typeof motion.img>, \"onClick\">\n> = ({ src, className, alt, ...props }) => {\n    const [isOpen, setIsOpen] = useState(false);\n    const [mounted, setMounted] = useState(false);\n\n    const imageRef = useRef<HTMLDivElement>(null);\n\n    useEffect(() => {\n        setMounted(true);\n\n        return () => setMounted(false);\n    }, []);\n\n    useClickOutside({\n        ref: imageRef,\n        callback: () => setIsOpen(false),\n    });\n\n    useEventListener(\"scroll\", () => isOpen && setIsOpen(false));\n\n    const handleClick = (e: React.MouseEvent<HTMLImageElement, MouseEvent>) => {\n        e.stopPropagation();\n        setIsOpen((prev) => !prev);\n    };\n\n    if (!mounted) return null;\n\n    const thumbnail = (\n        <motion.img\n            src={src}\n            alt={alt}\n            layoutId=\"morph-image\"\n            className={cn(\n                \"w-full h-full object-cover object-center not-prose cursor-zoom-in\",\n                className,\n            )}\n            onClick={() => setIsOpen(true)}\n            transition={transition}\n            {...props}\n        />\n    );\n\n    const modal = createPortal(\n        <AnimatePresence mode=\"wait\">\n            {isOpen && (\n                <>\n                    <motion.div\n                        key=\"backdrop\"\n                        className=\"fixed inset-0 z-40 bg-black/80\"\n                        initial={{ opacity: 0 }}\n                        animate={{ opacity: 1 }}\n                        exit={{ opacity: 0 }}\n                        transition={transition}\n\n                        // onClick={handleClick}\n                    />\n                    <motion.div\n                        key=\"container\"\n                        className=\"fixed inset-0 z-50 flex items-center justify-center pointer-events-none\"\n                        initial={{ opacity: 0 }}\n                        animate={{ opacity: 1 }}\n                        exit={{ opacity: 0 }}\n                        transition={transition}\n                    >\n                        <motion.img\n                            ref={imageRef as React.RefObject<HTMLImageElement>}\n                            src={src}\n                            alt={alt}\n                            layoutId=\"morph-image\"\n                            className={cn(\n                                \"object-cover object-center max-w-[90vw] max-h-[90vh] pointer-events-auto cursor-zoom-out\",\n                            )}\n                            onClick={(e) => handleClick(e)}\n                            transition={transition}\n                        />\n                    </motion.div>\n                </>\n            )}\n        </AnimatePresence>,\n        document.body,\n    );\n\n    return (\n        <div className=\"w-fit flex items-center justify-center\">\n            <picture>{thumbnail}</picture>\n            {modal}\n        </div>\n    );\n};\n\nexport default MorphImage;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york/hooks/useClickOutside.ts",
      "content": "import { useEventListener } from \"@/registry/new-york/hooks/useEventListener\";\n\ntype EventType =\n    | \"mousedown\"\n    | \"mouseup\"\n    | \"touchstart\"\n    | \"touchend\"\n    | \"focusin\"\n    | \"focusout\";\n\ninterface UseClickOutsideProps<T extends HTMLElement = HTMLElement> {\n    ref: React.RefObject<T | null> | React.RefObject<T | null>[];\n    callback: (event: MouseEvent | TouchEvent | FocusEvent) => void;\n    eventType?: EventType;\n    eventListenerOptions?: AddEventListenerOptions;\n}\n\nexport const useClickOutside = <T extends HTMLElement = HTMLElement>({\n    ref,\n    callback,\n    eventType = \"mousedown\",\n    eventListenerOptions,\n}: UseClickOutsideProps<T>): void => {\n    useEventListener(\n        eventType,\n        (event) => {\n            const target = event.target as Node;\n\n            if (!target || !target.isConnected) return;\n\n            if (!ref) return;\n\n            const isOutside = Array.isArray(ref)\n                ? ref\n                      .filter((r) => Boolean(r.current))\n                      .every((r) => r.current && !r.current.contains(target))\n                : ref.current && !ref.current.contains(target);\n\n            if (isOutside) {\n                callback(event);\n            }\n        },\n        undefined,\n        eventListenerOptions,\n    );\n};\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/hooks/useEventListener.ts",
      "content": "import { useEffect, useRef } from \"react\";\nimport type { RefObject } from \"react\";\n\nimport { useIsomorphicLayoutEffect } from \"@/registry/new-york/hooks/useIsomorphicLayoutEffect\";\n\n// MediaQueryList Event based useEventListener interface\nfunction useEventListener<K extends keyof MediaQueryListEventMap>(\n    eventName: K,\n    handler: (event: MediaQueryListEventMap[K]) => void,\n    element: RefObject<MediaQueryList>,\n    options?: boolean | AddEventListenerOptions,\n): void;\n\n// Window Event based useEventListener interface\nfunction useEventListener<K extends keyof WindowEventMap>(\n    eventName: K,\n    handler: (event: WindowEventMap[K]) => void,\n    element?: undefined,\n    options?: boolean | AddEventListenerOptions,\n): void;\n\n// Element Event based useEventListener interface\nfunction useEventListener<\n    K extends keyof HTMLElementEventMap & keyof SVGElementEventMap,\n    T extends Element = K extends keyof HTMLElementEventMap\n        ? HTMLDivElement\n        : SVGElement,\n>(\n    eventName: K,\n    handler:\n        | ((event: HTMLElementEventMap[K]) => void)\n        | ((event: SVGElementEventMap[K]) => void),\n    element: RefObject<T>,\n    options?: boolean | AddEventListenerOptions,\n): void;\n\n// Document Event based useEventListener interface\nfunction useEventListener<K extends keyof DocumentEventMap>(\n    eventName: K,\n    handler: (event: DocumentEventMap[K]) => void,\n    element: RefObject<Document>,\n    options?: boolean | AddEventListenerOptions,\n): void;\n\nfunction useEventListener<\n    KW extends keyof WindowEventMap,\n    KH extends keyof HTMLElementEventMap & keyof SVGElementEventMap,\n    KM extends keyof MediaQueryListEventMap,\n    T extends HTMLElement | SVGAElement | MediaQueryList = HTMLElement,\n>(\n    eventName: KW | KH | KM,\n    handler: (\n        event:\n            | WindowEventMap[KW]\n            | HTMLElementEventMap[KH]\n            | SVGElementEventMap[KH]\n            | MediaQueryListEventMap[KM]\n            | Event,\n    ) => void,\n    element?: RefObject<T>,\n    options?: boolean | AddEventListenerOptions,\n) {\n    // Create a ref that stores handler\n    const savedHandler = useRef(handler);\n\n    useIsomorphicLayoutEffect(() => {\n        savedHandler.current = handler;\n    }, [handler]);\n\n    useEffect(() => {\n        // Define the listening target\n        const targetElement: T | Window = element?.current ?? window;\n\n        if (!(targetElement && (targetElement?.addEventListener ?? false)))\n            return;\n\n        // Create event listener that calls handler function stored in ref\n        const listener: typeof handler = (event) => {\n            savedHandler.current(event);\n        };\n\n        targetElement.addEventListener(eventName, listener, options);\n\n        // Remove event listener on cleanup\n        return () => {\n            targetElement.removeEventListener(eventName, listener, options);\n        };\n    }, [eventName, element, options]);\n}\n\nexport { useEventListener };\n",
      "type": "registry:hook"
    }
  ]
}