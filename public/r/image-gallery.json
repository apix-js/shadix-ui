{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-gallery",
  "type": "registry:component",
  "description": "A image gallery component for shadcn/ui. Easily create a image gallery with a list of images",
  "dependencies": [
    "motion"
  ],
  "registryDependencies": [
    "@shadix-ui/morph-image"
  ],
  "files": [
    {
      "path": "registry/new-york/components/image-gallery.tsx",
      "content": "\"use client\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport type React from \"react\";\n\nimport MorphImage from \"@/registry/new-york/components/morph-image\";\nimport { useMasonry } from \"@/registry/new-york/hooks/useMasonry\";\nimport { useWindowSize } from \"@/registry/new-york/hooks/useWindowSize\";\nimport { cn } from \"@/shadcn/lib/utils\";\n\nexport interface ImageGalleryProps {\n    /** @public (required) - Array of images to display in the gallery */\n    images: ImageItem[];\n    /** @public (optional) - Space between images in pixels (default: 16) */\n    gap?: number;\n    /** @public (optional) - Columns to display in each screen size */\n    columns?: {\n        desktop?: number;\n        tablet?: number;\n        mobile?: number;\n    };\n    /** @public (optional) - Enable laxy loading of images (default: true) */\n    lazyLoading?: boolean;\n    /** @public (optional) - class name for the container */\n    className?: string;\n    /** @public (optional) - Callback when an image is clicked */\n    onImageClick?: (image: ImageItem, index: number) => void;\n    /** @public (optional) - Callback to filter images before rendering */\n    filterImages?: (images: ImageItem, index: number) => boolean;\n    /** @public (optional) - Callback sort images */\n    sortImages?: (a: ImageItem, b: ImageItem) => number;\n}\n\nexport interface ImageItem {\n    src: string;\n    alt: string;\n    width?: number;\n    height?: number;\n}\n\nconst observerOptions = {\n    root: null,\n    rootMargin: \"500px\",\n    threshold: 0.01,\n};\n\nconst ImageGallery: React.FC<ImageGalleryProps> = ({\n    images,\n    gap = 16,\n    columns = {\n        desktop: 3,\n        tablet: 2,\n        mobile: 1,\n    },\n    lazyLoading = true,\n    className,\n    onImageClick,\n    filterImages,\n    sortImages,\n}) => {\n    const [containerWidth, setContainerWidth] = useState(0);\n    const [loadedImages, setLoadedImages] = useState<Set<string>>(new Set());\n\n    const containerRef = useRef<HTMLDivElement>(null);\n\n    const windowSize = useWindowSize();\n\n    useEffect(() => {\n        const container = containerRef.current;\n        if (!container) return;\n\n        // Set initial width - use a small delay to ensure layout is complete\n        const timer = setTimeout(() => {\n            setContainerWidth(container.clientWidth);\n        }, 100);\n\n        // Create ResizeObserver to track container size changes\n        const resizeObserver = new ResizeObserver(() => {\n            setContainerWidth(container.clientWidth);\n        });\n\n        resizeObserver.observe(container);\n\n        return () => {\n            clearTimeout(timer);\n            resizeObserver.disconnect();\n        };\n    }, []);\n\n    const noOfColumns = useMemo(() => {\n        if (windowSize.width < 768) return columns.mobile || 1;\n        if (windowSize.width < 1024) return columns.tablet || 2;\n        return columns.desktop as number;\n    }, [windowSize.width, columns.mobile, columns.tablet, columns.desktop]);\n\n    // Randomize dimensions for images that don't have them\n    const getRandomDimensions = useCallback(() => {\n        const aspectRatios = [0.75, 1, 1.5, 2];\n        const randomAspectRatio =\n            aspectRatios[Math.floor(Math.random() * aspectRatios.length)];\n        const baseWidth = 600;\n        const width = baseWidth + Math.floor(Math.random() * 400);\n        const height = Math.round(width / randomAspectRatio);\n        return { width, height };\n    }, []);\n\n    const processedImages = useMemo(() => {\n        let result = [...images];\n\n        // Add random dimensions to images that don't have them\n        result = result.map((image) => {\n            if (!image.width || !image.height) {\n                return {\n                    ...image,\n                    ...getRandomDimensions(),\n                };\n            }\n            return image;\n        });\n\n        if (filterImages) {\n            result = result.filter((image, index) =>\n                filterImages(image, index),\n            );\n        }\n\n        if (sortImages) {\n            result = result.sort((a, b) => sortImages(a, b));\n        }\n\n        return result;\n    }, [images, filterImages, sortImages, getRandomDimensions]);\n\n    const { layout, totalHeight } = useMasonry(\n        processedImages,\n        containerWidth,\n        {\n            gap,\n            columns: noOfColumns as number,\n        },\n    );\n\n    // Load initially visible images + those within buffer to prevent blinking\n    useEffect(() => {\n        if (layout.length === 0) return;\n\n        let observer: IntersectionObserver | null = null;\n\n        // Use requestAnimationFrame to ensure DOM is rendered before observing\n        const rafId = requestAnimationFrame(() => {\n            const imageElements =\n                containerRef.current?.querySelectorAll(\"[data-src]\");\n\n            // Preload initially visible images + buffer area\n            const imagesToLoad = new Set<string>();\n            imageElements?.forEach((el) => {\n                const src = (el as HTMLElement).dataset.src;\n                if (src) {\n                    const rect = el.getBoundingClientRect();\n                    // Preload images within large buffer to prevent blinking\n                    if (\n                        rect.top < window.innerHeight + 500 &&\n                        rect.bottom > -500\n                    ) {\n                        imagesToLoad.add(src);\n                    }\n                }\n            });\n\n            if (imagesToLoad.size > 0) {\n                setLoadedImages((prev) => {\n                    const newSet = new Set(prev);\n                    imagesToLoad.forEach((src) => {\n                        newSet.add(src);\n                    });\n                    return newSet;\n                });\n            }\n\n            // Setup observer for lazy loading remaining images\n            observer = new IntersectionObserver((entries) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        const src = (entry.target as HTMLElement).dataset.src;\n\n                        if (src) {\n                            // Mark image as loaded when entering viewport\n                            setLoadedImages((prev) => {\n                                const newSet = new Set(prev);\n                                newSet.add(src);\n                                return newSet;\n                            });\n                            if (observer) {\n                                observer.unobserve(entry.target);\n                            }\n                        }\n                    }\n                });\n            }, observerOptions);\n\n            imageElements?.forEach((el) => {\n                if (observer) {\n                    observer.observe(el);\n                }\n            });\n        });\n\n        return () => {\n            cancelAnimationFrame(rafId);\n            if (observer) {\n                observer.disconnect();\n            }\n        };\n    }, [layout.length]);\n\n    const handleImageClick = useCallback(\n        (image: ImageItem, index: number) => {\n            onImageClick?.(image, index);\n        },\n        [onImageClick],\n    );\n\n    return (\n        <div\n            ref={containerRef}\n            className={cn(\"w-full relative\", className)}\n            style={{\n                height: `${totalHeight}px`,\n            }}\n        >\n            {layout.map((item, index) => {\n                const shouldLoadImage =\n                    !lazyLoading || loadedImages.has(item.src);\n\n                return (\n                    <div\n                        key={`${item.src}-${index}`}\n                        data-src={item.src}\n                        className={cn(\n                            \"rounded-lg\",\n                            lazyLoading &&\n                                !shouldLoadImage &&\n                                \"bg-muted-foreground/10 animate-pulse\",\n                        )}\n                        style={{\n                            position: \"absolute\",\n                            left: `${item.x}px`,\n                            top: `${item.y}px`,\n                            width: `${item.displayWidth}px`,\n                            height: `${item.displayHeight}px`,\n                            overflow: \"hidden\",\n                        }}\n                    >\n                        {shouldLoadImage ? (\n                            <MorphImage\n                                src={item.src}\n                                alt={item.alt}\n                                className=\"w-full h-full\"\n                                layoutId={`image-gallery-${index}`}\n                                onClick={() => handleImageClick(item, index)}\n                            />\n                        ) : null}\n                    </div>\n                );\n            })}\n        </div>\n    );\n};\n\nexport { ImageGallery };\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york/hooks/useMasonry.ts",
      "content": "import { useEffect, useState } from \"react\";\n\nimport type { ImageItem } from \"@/registry/new-york/components/image-gallery\";\n\nexport interface MasonryItem extends ImageItem {\n    x: number;\n    y: number;\n    displayHeight: number;\n    displayWidth: number;\n}\n\nexport interface MasonryConfig {\n    gap: number;\n    columns: number;\n}\n\nconst useMasonry = (\n    images: ImageItem[],\n    containerWidth: number,\n    config: MasonryConfig,\n) => {\n    const [layout, setLayout] = useState<MasonryItem[]>([]);\n    const [totalHeight, setTotalHeight] = useState(0);\n\n    useEffect(() => {\n        if (!containerWidth || images.length === 0 || config.columns < 1)\n            return;\n\n        // Column-based masonry with no gaps - scale images to fill column width\n        const totalGapWidth = config.gap * (config.columns - 1);\n        const availableWidth = containerWidth - totalGapWidth;\n        const columnWidth = availableWidth / config.columns;\n\n        const columnHeights: number[] = Array(config.columns).fill(0);\n        const columnImages: ImageItem[][] = Array(config.columns)\n            .fill(null)\n            .map(() => []);\n\n        // Distribute images to columns (shortest first)\n        images.forEach((image) => {\n            const columnIndex = columnHeights.indexOf(\n                Math.min(...columnHeights),\n            );\n\n            // Use provided dimensions or default to square (1:1) aspect ratio\n            const aspectRatio =\n                image.width && image.height ? image.width / image.height : 1; // Default to square if dimensions not provided\n\n            const displayWidth = columnWidth;\n            const displayHeight = displayWidth / aspectRatio;\n\n            columnHeights[columnIndex] += displayHeight + config.gap;\n            columnImages[columnIndex]?.push(image);\n        });\n\n        // Now position images in their columns and scale to fill gaps\n        const newLayout: MasonryItem[] = [];\n        const maxHeight = Math.max(...columnHeights) - config.gap;\n\n        columnImages.forEach((column, colIndex) => {\n            if (column.length === 0) return;\n\n            // Calculate total height used by images without gaps\n            let totalImageHeight = 0;\n            column.forEach((image) => {\n                // Handle optional dimensions\n                const aspectRatio =\n                    image.width && image.height\n                        ? image.width / image.height\n                        : 1;\n                const displayWidth = columnWidth;\n                const displayHeight = displayWidth / aspectRatio;\n                totalImageHeight += displayHeight;\n            });\n\n            // Scale factor to fill the entire column height\n            const totalGaps = config.gap * (column.length - 1);\n            const scaleFactor = (maxHeight - totalGaps) / totalImageHeight;\n\n            // Position images in column with scaling\n            let columnY = 0;\n            column.forEach((image) => {\n                // Handle optional dimensions\n                const aspectRatio =\n                    image.width && image.height\n                        ? image.width / image.height\n                        : 1;\n                const displayWidth = columnWidth;\n                const displayHeight =\n                    (displayWidth / aspectRatio) * scaleFactor;\n\n                const x = colIndex * (columnWidth + config.gap);\n                const y = columnY;\n\n                newLayout.push({\n                    ...image,\n                    x,\n                    y,\n                    displayWidth,\n                    displayHeight,\n                });\n\n                columnY += displayHeight + config.gap;\n            });\n        });\n\n        setLayout(newLayout);\n        setTotalHeight(maxHeight);\n    }, [images, containerWidth, config.gap, config.columns]);\n\n    return {\n        layout,\n        totalHeight,\n    };\n};\n\nexport { useMasonry };\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/hooks/useWindowSize.ts",
      "content": "import { useState } from \"react\";\n\nimport { useEventListener } from \"@/registry/new-york/hooks/useEventListener\";\n\nconst useWindowSize = () => {\n    const [windowSize, setWindowSize] = useState({\n        width: typeof window !== \"undefined\" ? window.innerWidth : 0,\n        height: typeof window !== \"undefined\" ? window.innerHeight : 0,\n    });\n\n    const handleResize = () => {\n        setWindowSize({\n            width: window.innerWidth,\n            height: window.innerHeight,\n        });\n    };\n\n    useEventListener(\"resize\", handleResize);\n\n    return windowSize;\n};\n\nexport { useWindowSize };\n",
      "type": "registry:hook"
    }
  ]
}