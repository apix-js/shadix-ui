{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "signature-pad",
  "type": "registry:component",
  "description": "A signature pad component for capturing signatures",
  "dependencies": [
    "class-variance-authority",
    "lucide-react"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "registry/new-york/components/signature-pad.tsx",
      "content": "\"use client\";\n\nimport React, {\n    type MouseEvent,\n    type TouchEvent,\n    useEffect,\n    useImperativeHandle,\n    useRef,\n    useState,\n} from \"react\";\n\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport { BrushCleaning, Save } from \"lucide-react\";\n\nimport { Button } from \"@/shadcn/components/ui/button\";\nimport { cn } from \"@/shadcn/lib/utils\";\n\nconst signaturePadVariants = cva(\"touch-none cursor-pencil\", {\n    variants: {\n        variant: {\n            default: \"border border-input bg-input/30\",\n            ghost: \"border-none bg-muted/50\",\n            outline: \"border-2 border-primary bg-background\",\n        },\n        size: {\n            default: \"w-full h-[200px]\",\n            sm: \"w-full h-[150px]\",\n            md: \"w-full h-[250px]\",\n            lg: \"w-full h-[300px]\",\n        },\n    },\n    defaultVariants: {\n        variant: \"default\",\n        size: \"default\",\n    },\n});\n\nexport interface SignaturePadProps\n    extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\">,\n        VariantProps<typeof signaturePadVariants> {\n    /** @public (optional) - Tailwind color utility class for the pen color (e.g. \"text-black\", \"text-primary-500\") */\n    penColor?: string;\n    /** @public (optional) - Line width in pixels */\n    lineWidth?: number;\n    /** @public (optional) - Whether to show the buttons */\n    showButtons?: boolean;\n    /** @public (optional) - The icon to display for the save button */\n    saveButtonIcon?: React.ReactNode;\n    /** @public (optional) - The icon to display for the clear button */\n    clearButtonIcon?: React.ReactNode;\n    /** @public (optional) - Callback function to be called when the signature is saved */\n    onSave?: (signature: Base64URLString) => void;\n    /** @public (optional) - Callback function to be called when the signature is changed */\n    onChange?: (signature: Base64URLString | null) => void;\n}\n\ninterface SignaturePadRef {\n    clear: () => void;\n    save: () => void;\n    toDataURL: () => Base64URLString | null;\n    isEmpty: () => boolean;\n    getCanvas: () => HTMLCanvasElement | null;\n}\n\n/**\n * Signature Pad component\n * @param {SignaturePadProps} props - The props for the SignaturePad component\n * @param {React.Ref<SignaturePadRef>} ref - The ref for the SignaturePad component\n * @returns {React.ReactNode} The SignaturePad component\n *\n * @requires Add this import to your global CSS:\n * @import '@styles/signature-pad.css'; // or relative path to the styles file based on your components.json file\n *\n * Or add this to your tailwind.config.ts:\n * theme: {\n *   extend: {\n *     cursor: {\n *       pencil: 'url(\"data:image/svg+xml...\") 0 24, pointer'\n *     }\n *   }\n * }\n *\n * @example\n * <SignaturePad\n *     penColor=\"hsl(var(--foreground))\"\n *     lineWidth={4}\n *     showButtons={true}\n *     saveButtonIcon={<Save />}\n *     clearButtonIcon={<BrushCleaning />}\n * />\n */\n\nconst SignaturePad = React.forwardRef<SignaturePadRef, SignaturePadProps>(\n    (\n        {\n            penColor = \"hsl(var(--foreground))\",\n            lineWidth = 4,\n            showButtons = true,\n            saveButtonIcon,\n            clearButtonIcon,\n            variant,\n            size,\n            className,\n            onSave,\n            onChange,\n            ...props\n        },\n        ref,\n    ) => {\n        const [isDrawing, setIsDrawing] = useState(false);\n        const [isEmpty, setIsEmpty] = useState(true);\n\n        const pointsRef = useRef<{ x: number; y: number }[]>([]);\n        const canvasRef = useRef<HTMLCanvasElement>(null);\n        const ctxRef = useRef<CanvasRenderingContext2D | null>(null);\n\n        // Expose the clear, save, toDataURL, isEmpty, and getCanvas methods to the parent component\n        useImperativeHandle(ref, () => ({\n            clear: handleClear,\n            save: handleSave,\n            toDataURL: () => {\n                const canvas = canvasRef.current;\n                if (!canvas) return null;\n                return canvas.toDataURL(\"image/png\") as Base64URLString;\n            },\n            isEmpty: () => isEmpty,\n            getCanvas: () => canvasRef.current,\n        }));\n\n        // Update the canvas size for High DPI displays\n        useEffect(() => {\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n\n            const updateCanvasSize = () => {\n                const rect = canvas.getBoundingClientRect();\n                const ratio = window.devicePixelRatio || 1;\n\n                canvas.width = rect.width * ratio;\n                canvas.height = rect.height * ratio;\n                canvas.style.width = `${rect.width}px`;\n                canvas.style.height = `${rect.height}px`;\n\n                const ctx = canvas.getContext(\"2d\");\n                if (ctx) {\n                    ctx.scale(ratio, ratio);\n                    ctx.lineCap = \"round\";\n                    ctx.lineJoin = \"round\";\n                    ctx.strokeStyle = penColor;\n                    ctx.lineWidth = lineWidth;\n\n                    ctx.imageSmoothingEnabled = true;\n                    ctx.imageSmoothingQuality = \"high\";\n                    ctx.globalCompositeOperation = \"source-over\";\n\n                    ctxRef.current = ctx;\n                }\n            };\n\n            updateCanvasSize();\n            window.addEventListener(\"resize\", updateCanvasSize);\n            return () => {\n                window.removeEventListener(\"resize\", updateCanvasSize);\n            };\n        }, [penColor, lineWidth]);\n\n        // Get the pointer position on the canvas\n        const getPointerPosition = (e: MouseEvent | TouchEvent) => {\n            const canvas = canvasRef.current;\n            if (!canvas) return null;\n\n            const rect = canvas.getBoundingClientRect();\n\n            if (\"touches\" in e) {\n                return {\n                    x: e.touches[0].clientX - rect.left,\n                    y: e.touches[0].clientY - rect.top,\n                };\n            }\n\n            return {\n                x: e.clientX - rect.left,\n                y: e.clientY - rect.top,\n            };\n        };\n\n        // Start drawing on the canvas\n        const startDrawing = (e: MouseEvent | TouchEvent) => {\n            e.preventDefault();\n\n            const pointerPosition = getPointerPosition(e);\n\n            if (!pointerPosition) return;\n\n            setIsDrawing(true);\n            pointsRef.current = [pointerPosition];\n            setIsEmpty(false);\n        };\n\n        const draw = (e: MouseEvent | TouchEvent) => {\n            e.preventDefault();\n            if (!isDrawing) return;\n\n            const canvas = canvasRef.current;\n            let ctx = ctxRef.current;\n\n            if (!ctx)\n                ctx = canvas?.getContext(\"2d\") as CanvasRenderingContext2D;\n\n            const newPoint = getPointerPosition(e);\n\n            if (ctx && newPoint) {\n                const updated = [...pointsRef.current, newPoint];\n\n                if (updated.length < 2) {\n                    pointsRef.current = updated;\n                    return;\n                }\n\n                if (updated.length === 2) {\n                    ctx.beginPath();\n                    ctx.moveTo(updated[0].x, updated[0].y);\n                    ctx.lineTo(updated[1].x, updated[1].y);\n                    ctx.stroke();\n\n                    pointsRef.current = updated;\n                    return;\n                }\n\n                const previous = updated[updated.length - 3];\n                const current = updated[updated.length - 2];\n                const next = updated[updated.length - 1];\n\n                const cp1x = (previous.x + current.x) / 2;\n                const cp1y = (previous.y + current.y) / 2;\n\n                const cp2x = (current.x + next.x) / 2;\n                const cp2y = (current.y + next.y) / 2;\n\n                ctx.beginPath();\n                ctx.moveTo(cp1x, cp1y);\n                ctx.quadraticCurveTo(current.x, current.y, cp2x, cp2y);\n                ctx.stroke();\n\n                pointsRef.current = updated.slice(-3);\n                return;\n            }\n        };\n\n        const stopDrawing = () => {\n            setIsDrawing(false);\n            pointsRef.current = [];\n            if (isDrawing) {\n                onChange?.(\n                    canvasRef.current?.toDataURL(\n                        \"image/png\",\n                    ) as Base64URLString,\n                );\n            }\n        };\n\n        const handleClear = () => {\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) return;\n\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            setIsEmpty(true);\n            onChange?.(null);\n        };\n\n        const handleSave = () => {\n            const canvas = canvasRef.current;\n            if (!canvas && isEmpty) return;\n\n            const dataURL = canvas?.toDataURL(\"image/png\");\n            onSave?.(dataURL as Base64URLString);\n        };\n\n        return (\n            <div className={cn(\"w-full relative\", className)} {...props}>\n                <canvas\n                    ref={canvasRef}\n                    className={cn(\n                        \"rounded-lg cursor-pencil\",\n                        signaturePadVariants({ variant, size }),\n                    )}\n                    onMouseDown={startDrawing}\n                    onMouseMove={draw}\n                    onMouseUp={stopDrawing}\n                    onMouseLeave={stopDrawing}\n                    onTouchStart={startDrawing}\n                    onTouchMove={draw}\n                    onTouchEnd={stopDrawing}\n                />\n\n                {showButtons && (\n                    <div className=\"absolute bottom-2 right-2 flex gap-1\">\n                        <Button\n                            variant=\"outline\"\n                            size=\"icon-sm\"\n                            onClick={handleClear}\n                            className=\"rounded-full\"\n                        >\n                            {clearButtonIcon || <BrushCleaning />}\n                        </Button>\n                        <Button\n                            variant=\"outline\"\n                            size=\"icon-sm\"\n                            onClick={handleSave}\n                            className=\"rounded-full\"\n                        >\n                            {saveButtonIcon || <Save />}\n                        </Button>\n                    </div>\n                )}\n            </div>\n        );\n    },\n);\n\nexport default SignaturePad;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york/styles/signature-pad.css",
      "content": "@layer base {\n    .cursor-pencil {\n        cursor:\n            url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' viewBox='0 0 24 24'><path d='M12 20h9'/><path d='M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z'/></svg>\")\n            0 24,\n            pointer;\n    }\n}\n",
      "type": "registry:style"
    }
  ]
}